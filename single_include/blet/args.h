// Generated by amalgamate.py
#ifndef AMALGAMATE_GUARD__SINGLE_INCLUDE_BLET_ARGS_H_
#define AMALGAMATE_GUARD__SINGLE_INCLUDE_BLET_ARGS_H_

// -------------------------
// Start include/blet/args.h
// -------------------------
/**
 * args.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2023 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef BLET_ARGS_H_
#define BLET_ARGS_H_

// #include "blet/args/action.h"
// --------------------------------
// Start include/blet/args/action.h
// --------------------------------

/**
 * args/action.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2023 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef BLET_ARGS_ACTION_H_
#define BLET_ARGS_ACTION_H_

namespace blet {

namespace args {

struct Action {
    enum eAction {
        NONE = 0,
        HELP,
        VERSION,
        STORE_TRUE,
        STORE_FALSE,
        APPEND,
        EXTEND,
        INFINITE
    };
};

} // namespace args

} // namespace blet

#endif // #ifndef BLET_ARGS_ACTION_H_

// ------------------------------
// End include/blet/args/action.h
// ------------------------------

// #include "blet/args/args.h"
// ------------------------------
// Start include/blet/args/args.h
// ------------------------------
/**
 * args/args.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2023 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef BLET_ARGS_ARGS_H_
#define BLET_ARGS_ARGS_H_

#include <list>
#include <map>
#include <string>
#include <vector>

// #include "blet/args/action.h" (already included)
// #include "blet/args/argument.h"
// ----------------------------------
// Start include/blet/args/argument.h
// ----------------------------------
/**
 * args/argument.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2023 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef BLET_ARGS_ARGUMENT_H_
#define BLET_ARGS_ARGUMENT_H_

#include <cstdlib> // stdtod
#include <cstring> // memcpy
#include <string>
#include <vector>

// #include "blet/args/action.h" (already included)
// #include "blet/args/exception.h"
// -----------------------------------
// Start include/blet/args/exception.h
// -----------------------------------

/**
 * args/exception.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2023 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef BLET_ARGS_EXCEPTION_H_
#define BLET_ARGS_EXCEPTION_H_

#include <exception>
#include <string>

namespace blet {

namespace args {

/**
 * @brief Basic exception from std::exception
 */
class Exception : public std::exception {
  public:
    Exception(const char* str);
    virtual ~Exception() throw();
    const char* what() const throw();

  protected:
    std::string str_;
};

/**
 * @brief Usage exception from Exception
 */
struct HelpException : public Exception {
    HelpException(const char* message);
    virtual ~HelpException() throw();
};

/**
 * @brief Version exception from Exception
 */
struct VersionException : public Exception {
    VersionException(const char* message);
    virtual ~VersionException() throw();
};

/**
 * @brief Argument exception from Exception
 */
class ArgumentException : public Exception {
  public:
    ArgumentException(const char* message);
    ArgumentException(const char* argument, const char* message);
    virtual ~ArgumentException() throw();
    const char* argument() const throw();

  protected:
    std::string argument_;
};

struct AccessDeniedException : public ArgumentException {
    AccessDeniedException(const char* argument, const char* message);
    virtual ~AccessDeniedException() throw();
};

struct ParseArgumentException : public ArgumentException {
    ParseArgumentException(const char* message);
    ParseArgumentException(const char* argument, const char* message);
    virtual ~ParseArgumentException() throw();
};

struct ParseArgumentRequiredException : public ParseArgumentException {
    ParseArgumentRequiredException(const char* argument, const char* message);
    virtual ~ParseArgumentRequiredException() throw();
};

struct ParseArgumentValidException : public ParseArgumentException {
    ParseArgumentValidException(const char* message);
    ParseArgumentValidException(const char* argument, const char* message);
    virtual ~ParseArgumentValidException() throw();
};

} // namespace args

} // namespace blet

#endif // #ifndef BLET_ARGS_EXCEPTION_H_

// ---------------------------------
// End include/blet/args/exception.h
// ---------------------------------

// #include "blet/args/valid.h"
// -------------------------------
// Start include/blet/args/valid.h
// -------------------------------

/**
 * args/valid.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2023 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef BLET_ARGS_VALID_H_
#define BLET_ARGS_VALID_H_

#include <string>
#include <vector>

namespace blet {

namespace args {

/**
 * @brief Interface for validate argument
 */
class IValid {
  public:
    /**
     * @brief Destroy the IValid object
     */
    inline virtual ~IValid() {}

    /**
     * @brief check if arguments are valid
     *
     * @param arguments
     * @return [true] arguments are valid, [false] arguments are not valid
     */
    virtual bool isValid(std::vector<std::string>& arguments) = 0;
};

class ValidNumber : public IValid {
  public:
    /**
     * @brief Construct a new Valid Number object
     */
    ValidNumber();

    /**
     * @brief Destroy the Valid Number object
     */
    ~ValidNumber();

    /**
     * @brief check if arguments are valid
     *
     * @param arguments
     * @return [true] arguments are valid, [false] arguments are not valid
     */
    bool isValid(std::vector<std::string>& args);
};

class ValidMinMax : public IValid {
  public:
    /**
     * @brief Construct a new Valid Min Max object
     * at call self @c isValid it check if arguments are between of @p min and @p max
     *
     * @param min
     * @param max
     */
    ValidMinMax(double min, double max);

    /**
     * @brief Destroy the Valid Min Max object
     */
    ~ValidMinMax();

    /**
     * @brief check if arguments are valid
     *
     * @param arguments
     * @return [true] arguments are valid, [false] arguments are not valid
     */
    bool isValid(std::vector<std::string>& args);

  private:
    double min_;
    double max_;
};

class ValidChoise : public IValid {
  public:
    /**
     * @brief
     *
     * @param choises
     */
    ValidChoise(const std::vector<std::string>& choises);

    /**
     * @brief Destroy the Valid Choise object
     */
    ~ValidChoise();

    /**
     * @brief check if arguments are valid
     *
     * @param arguments
     * @return [true] arguments are valid, [false] arguments are not valid
     */
    bool isValid(std::vector<std::string>& args);

  private:
    std::vector<std::string> choises_;
};

class ValidPath : public IValid {
  public:
    enum eMode {
        ALL = 0,
        IS_FILE,
        IS_DIR
    };

    /**
     * @brief Construct a new Valid Path Exist object
     * at call self @c isValid it check if argument is a exist path
     */
    ValidPath(enum eMode mode = ValidPath::ALL);

    /**
     * @brief Destroy the Valid Path Exist object
     */
    ~ValidPath();

    /**
     * @brief check if arguments are valid
     *
     * @param arguments
     * @return [true] arguments are valid, [false] arguments are not valid
     */
    bool isValid(std::vector<std::string>& args);

  private:
    enum eMode mode_;
};

} // namespace args

} // namespace blet

#endif // #ifndef BLET_ARGS_VALID_H_

// -----------------------------
// End include/blet/args/valid.h
// -----------------------------

// #include "blet/args/vector.h"
// --------------------------------
// Start include/blet/args/vector.h
// --------------------------------

/**
 * args/vector.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2023 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef BLET_ARGS_VECTOR_H_
#define BLET_ARGS_VECTOR_H_

#include <string>
#include <vector>

namespace blet {

namespace args {

class Vector : public std::vector<std::string> {
  public:
    inline Vector() :
        std::vector<std::string>() {}

    inline Vector(int size) :
        std::vector<std::string>(size) {}

    template<std::size_t S>
    inline Vector(const char* (&v)[S]) :
        std::vector<std::string>() {
        std::vector<std::string>::reserve(S);
        for (std::size_t i = 0; i < S; ++i) {
            std::vector<std::string>::push_back(v[i]);
        }
    }

    template<std::size_t S>
    inline Vector(const char* const (&v)[S]) :
        std::vector<std::string>() {
        std::vector<std::string>::reserve(S);
        for (std::size_t i = 0; i < S; ++i) {
            std::vector<std::string>::push_back(v[i]);
        }
    }

    template<std::size_t S>
    inline Vector(const std::string (&v)[S]) :
        std::vector<std::string>() {
        std::vector<std::string>::reserve(S);
        for (std::size_t i = 0; i < S; ++i) {
            std::vector<std::string>::push_back(v[i]);
        }
    }

    template<std::size_t S>
    inline Vector(const char (&v)[S]) :
        std::vector<std::string>() {
        std::vector<std::string>::push_back(v);
    }

    inline Vector(const char*(&v)) :
        std::vector<std::string>() {
        std::vector<std::string>::push_back(v);
    }

    inline Vector(const std::string& v) :
        std::vector<std::string>() {
        std::vector<std::string>::push_back(v);
    }

#if __cplusplus >= 201103L
    inline Vector(const std::initializer_list<std::string>& l) :
        std::vector<std::string>(l) {}
#endif
};

} // namespace args

} // namespace blet

#endif // #ifndef BLET_ARGS_VECTOR_H_

// ------------------------------
// End include/blet/args/vector.h
// ------------------------------

// ------------------------------------
// Content include/blet/args/argument.h
// ------------------------------------

namespace blet {

class Usage;

namespace args {

template<typename T>
inline void boolTo(const bool&, T&) {
    throw ParseArgumentException("destination method not found for this type");
}

inline void boolTo(const bool& b, bool& ret) {
    ret = b;
}

inline void boolTo(const bool& b, char& ret) {
    ret = b;
}

inline void boolTo(const bool& b, unsigned char& ret) {
    ret = b;
}

inline void boolTo(const bool& b, short& ret) {
    ret = b;
}

inline void boolTo(const bool& b, unsigned short& ret) {
    ret = b;
}

inline void boolTo(const bool& b, int& ret) {
    ret = b;
}

inline void boolTo(const bool& b, unsigned int& ret) {
    ret = b;
}

inline void boolTo(const bool& b, long& ret) {
    ret = b;
}

inline void boolTo(const bool& b, unsigned long& ret) {
    ret = b;
}

#if __cplusplus >= 201103L
#ifdef _GLIBCXX_USE_LONG_LONG

inline void boolTo(const bool& b, long long& ret) {
    ret = b;
}

inline void boolTo(const bool& b, unsigned long long& ret) {
    ret = b;
}

#endif
#endif

inline void boolTo(const bool& b, float& ret) {
    ret = b;
}

inline void boolTo(const bool& b, double& ret) {
    ret = b;
}

inline void boolTo(const bool& b, long double& ret) {
    ret = b;
}

inline void boolTo(const bool& b, std::string& ret) {
    if (b) {
        ret = "true";
    }
    else {
        ret = "false";
    }
}

inline void boolTo(const bool& b, const char*& ret) {
    if (b) {
        ret = "true";
    }
    else {
        ret = "false";
    }
}

template<std::size_t Size>
inline void boolTo(const bool& b, char (&ret)[Size]) {
    if (b) {
        if (Size >= sizeof("true")) {
            ::memcpy(ret, "true", sizeof("true"));
        }
        else {
            ::memcpy(ret, "true", Size - 1);
            ret[Size - 1] = '\0';
        }
    }
    else {
        if (Size >= sizeof("false")) {
            ::memcpy(ret, "false", sizeof("false"));
        }
        else {
            ::memcpy(ret, "false", Size - 1);
            ret[Size - 1] = '\0';
        }
    }
}

template<typename T>
inline void strTo(const std::string&, T&) {
    throw ParseArgumentException("destination method not found for this type");
}

inline void strTo(const std::string& str, bool& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, char& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, unsigned char& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, short& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, unsigned short& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, int& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, unsigned int& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, long& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, unsigned long& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

#if __cplusplus >= 201103L
#ifdef _GLIBCXX_USE_LONG_LONG

inline void strTo(const std::string& str, long long& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, unsigned long long& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

#endif
#endif

inline void strTo(const std::string& str, float& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, double& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, long double& ret) {
    ret = ::strtod(str.c_str(), NULL);
}

inline void strTo(const std::string& str, std::string& ret) {
    ret = str;
}

inline void strTo(const std::string& str, const char*& ret) {
    ret = str.c_str();
}

template<std::size_t Size>
inline void strTo(const std::string& str, char (&ret)[Size]) {
    if (Size > str.size()) {
        ::memcpy(ret, str.c_str(), str.size());
        ret[str.size()] = '\0';
    }
    else {
        ::memcpy(ret, str.c_str(), Size - 1);
        ret[Size - 1] = '\0';
    }
}

class Args;

class ArgumentElement : public std::vector<ArgumentElement> {
    friend class Args;
    friend class Argument;
    friend class Usage;

  public:
    ArgumentElement();
    ArgumentElement(const ArgumentElement& rhs);
    ArgumentElement(const char* arg__, const char* default__);
    ArgumentElement(const char* arg);
    ~ArgumentElement();

    /**
     * @brief Get the string argument
     *
     * @return std::string
     */
    inline std::string getString() const {
        return argument_;
    }

    /**
     * @brief Get the default value of argument
     *
     * @return const std::string&
     */
    inline const std::string& getDefault() const {
        return default_;
    }

    /**
     * @brief Check if argument is number
     *
     * @return [true] if is number
     */
    inline bool isNumber() const {
        return isNumber_;
    }

    /**
     * @brief Get the number from argument if is number
     *
     * @return double
     *
     * @throw Exception is not a number
     */
    inline double getNumber() const {
        if (isNumber_) {
            return number_;
        }
        throw Exception("is not a number");
    }

    /**
     * @brief tranform to vector of string
     *
     * @return std::vector<std::string>
     *
     * @throw Exception convertion to vector of string not authorized
     */
    operator std::vector<std::string>() const;

    /**
     * @brief Friend function for convert Argument object to ostream
     *
     * @param os
     * @param argument
     * @return std::ostream&
     */
    inline friend std::ostream& operator<<(std::ostream& os, const ArgumentElement& argument) {
        os << argument.getString();
        return os;
    }

  protected:
    std::string argument_;
    std::string default_;
    bool isNumber_;
    double number_;
};

template<typename T>
class ArgumentType;

template<typename T>
class ArgumentVectorType;

template<typename T>
class ArgumentVectorVectorType;

/**
 * @brief Argument object
 */
class Argument : public ArgumentElement {
    friend class Args;
    friend class Usage;

  public:
    /**
     * @brief Construct a new Argument object
     */
    Argument(Args& args);

    /**
     * @brief Copy a Argument object
     *
     * @param rhs
     */
    Argument(const Argument& rhs);

    /**
     * @brief Destroy the Argument object
     */
    virtual ~Argument();

    inline bool isExists() const {
        return isExist_;
    }

    inline bool isRequired() const {
        return isRequired_;
    }

    inline std::size_t count() const {
        return count_;
    }

    inline std::size_t getNargs() const {
        return nargs_;
    }

    inline const std::string& getHelp() const {
        return help_;
    }

    inline const std::string& getMetavar() const {
        return metavar_;
    }

    inline const std::vector<std::string>& getNameOrFlags() const {
        return nameOrFlags_;
    }

    inline const std::vector<std::string>& getDefaults() const {
        return defaults_;
    }

    inline Action::eAction getAction() const {
        return action_;
    }

    std::string getString() const;

    /**
     * @brief Override bool operator
     *
     * @return true if exist or false if not exist
     */
    inline operator bool() const {
        if (type_ == REVERSE_BOOLEAN_OPTION) {
            return !isExist_;
        }
        else {
            return isExist_;
        }
    }

    /**
     * @brief tranform to string
     *
     * @return std::string
     */
    inline operator std::string() const {
        return getString();
    }

    /**
     * @brief tranform to vector of string
     *
     * @return std::vector<std::string>
     *
     * @throw Exception convertion to vector of string not authorized
     */
    operator std::vector<std::string>() const;

    /**
     * @brief tranform to vector of vector of string
     *
     * @return std::vector<std::vector<std::string> >
     *
     * @throw Exception convertion to vector of vector of string not authorized
     */
    operator std::vector<std::vector<std::string> >() const;

    /**
     * @brief tranform to number
     *
     * @tparam T
     * @return T
     */
    template<typename T>
    inline operator T() const {
        return getNumber();
    }

    /**
     * @brief overide brakcet operator
     *
     * @param index
     * @return const Argument&
     */
    inline const ArgumentElement& operator[](unsigned long index) const {
        return at(index);
    }

    /**
     * @brief Option strings, e.g. -f, --foo
     *
     * @param flag__
     * @return this reference
     *
     * @throw ArgumentException
     */
    Argument& flag(const char* flag__);

    /**
     * @brief The basic type of action to be taken when this argument is encountered at the command line
     *
     * @param action__
     * @return this reference
     *
     * @throw ArgumentException
     */
    Argument& action(enum Action::eAction action__);

    /**
     * @brief A brief description of what the argument does
     *
     * @param help__
     * @return this reference
     */
    inline Argument& help(const char* help__) {
        help_ = help__;
        return *this;
    }

    /**
     * @brief Whether or not the command-line option may be omitted (optionals only)
     *
     * @param required__
     * @return this reference
     */
    Argument& required(bool required__ = true);

    /**
     * @brief A name for the argument in usage messages
     *
     * @param metavar__
     * @return this reference
     */
    inline Argument& metavar(const char* metavar__) {
        metavar_ = metavar__;
        return *this;
    }

    /**
     * @brief The number of command-line arguments that should be consumed
     *
     * @param nargs__
     * @return this reference
     *
     * @throw ArgumentException
     */
    inline Argument& nargs(std::size_t nargs__) {
        nargs_ = nargs__;
        typeConstructor_();
        defaultsConstructor_();
        return *this;
    }

    /**
     * @brief The value produced if the argument is absent from the command line
     *
     * @param defaults__
     * @return this reference
     *
     * @throw ArgumentException
     */
    inline Argument& defaults(const Vector& defaults__) {
        defaults_ = defaults__;
        defaultsConstructor_();
        return *this;
    }

    /**
     * @brief New object from IValid interface
     *
     * @param pValid
     * @param isDeletable
     * @return this reference
     */
    inline Argument& valid(IValid* pValid, bool isDeletable = true) {
        if (valid_ != NULL && validDeletable_) {
            delete valid_;
        }
        valid_ = pValid;
        validDeletable_ = isDeletable;
        return *this;
    }

    /**
     * @brief Define a reference of object for insert the value after parseArguments method
     *
     * @tparam T
     * @param dest
     * @param toDest
     * @return reference of new argument
     */
    template<typename T>
    inline Argument& dest(std::vector<std::vector<T> >& dest,
                          void (*toDest)(std::vector<std::vector<T> >& dest, bool isExists,
                                         const std::vector<std::vector<std::string> >& arguments) = NULL) {
        bool validDeletable = validDeletable_;
        validDeletable_ = false;
        Argument* argumentType = new ArgumentVectorVectorType<T>(this, dest, toDest);
        argumentType->validDeletable_ = validDeletable;
        return *argumentType;
    }

    /**
     * @brief Define a reference of object for insert the value after parseArguments method
     *
     * @tparam T
     * @param dest
     * @param toDest
     * @return reference of new argument
     */
    template<typename T>
    inline Argument& dest(std::vector<T>& dest, void (*toDest)(std::vector<T>& dest, bool isExists,
                                                               const std::vector<std::string>& arguments) = NULL) {
        bool validDeletable = validDeletable_;
        validDeletable_ = false;
        Argument* argumentType = new ArgumentVectorType<T>(this, dest, toDest);
        argumentType->validDeletable_ = validDeletable;
        return *argumentType;
    }

    /**
     * @brief Define a reference of object for insert the value after parseArguments method
     *
     * @tparam T
     * @param dest
     * @param toDest
     * @return reference of new argument
     */
    template<typename T>
    inline Argument& dest(T& dest, void (*toDest)(T& dest, bool isExists, const std::string& argument) = NULL) {
        bool validDeletable = validDeletable_;
        validDeletable_ = false;
        Argument* argumentType = new ArgumentType<T>(this, dest, toDest);
        argumentType->validDeletable_ = validDeletable;
        return *argumentType;
    }

    /**
     * @brief Friend function for convert Argument object to ostream
     *
     * @param os
     * @param argument
     * @return std::ostream&
     */
    inline friend std::ostream& operator<<(std::ostream& os, const Argument& argument) {
        os << argument.getString();
        return os;
    }

  protected:
    enum Type {
        NONE = 0,
        HELP_OPTION,
        VERSION_OPTION,
        BOOLEAN_OPTION,
        REVERSE_BOOLEAN_OPTION,
        SIMPLE_OPTION,
        NUMBER_OPTION,
        INFINITE_OPTION,
        MULTI_OPTION,
        MULTI_INFINITE_OPTION,
        MULTI_NUMBER_OPTION,
        MULTI_NUMBER_INFINITE_OPTION,
        POSITIONAL_ARGUMENT,
        NUMBER_POSITIONAL_ARGUMENT,
        INFINITE_POSITIONAL_ARGUMENT,
        INFINITE_NUMBER_POSITIONAL_ARGUMENT
    };

    inline bool isPositionnalArgument_() const {
        switch (type_) {
            case POSITIONAL_ARGUMENT:
            case NUMBER_POSITIONAL_ARGUMENT:
            case INFINITE_POSITIONAL_ARGUMENT:
            case INFINITE_NUMBER_POSITIONAL_ARGUMENT:
                return true;
            default:
                return false;
        }
    }

    inline virtual void toDest_() {
        /* do nothing */
    }

    void toNumber_();

    std::string metavarDefault_();

    void typeConstructor_();

    void defaultsConstructor_();

    void sortNameOrFlags_();

    void clear_();

    static void validFormatFlag_(const char* flag);

    static bool compareOption_(const Argument* first, const Argument* second);

    Args& args_;

    std::vector<std::string> nameOrFlags_;
    enum Type type_;
    bool isExist_;
    bool isRequired_;
    std::size_t count_;
    std::size_t nargs_;
    std::string help_;
    std::string metavar_;

    IValid* valid_;
    bool validDeletable_;

    Argument** this_;
    enum Action::eAction action_;
    std::vector<std::string> defaults_;
};

template<typename T>
class ArgumentType : public Argument {
  public:
    inline ArgumentType(Argument* argument, T& dest, void (*toDest)(T&, bool, const std::string&)) :
        Argument(*argument),
        dest_(dest),
        toDestCustom_(toDest) {
        delete argument;
        *this_ = this;
    }
    inline virtual ~ArgumentType() {}

  private:
    inline void toDest_() {
        if (toDestCustom_ != NULL) {
            toDestCustom_(dest_, isExist_, argument_);
        }
        else {
            if (type_ == BOOLEAN_OPTION) {
                boolTo(isExist_, dest_);
            }
            else if (type_ == REVERSE_BOOLEAN_OPTION) {
                boolTo(!isExist_, dest_);
            }
            else {
                strTo(argument_, dest_);
            }
        }
    }

    T& dest_;
    void (*toDestCustom_)(T&, bool, const std::string&);
};

template<typename T>
class ArgumentVectorType : public Argument {
  public:
    inline ArgumentVectorType(Argument* argument, std::vector<T>& dest,
                              void (*toDest)(std::vector<T>&, bool, const std::vector<std::string>&)) :
        Argument(*argument),
        dest_(dest),
        toDestCustom_(toDest) {
        delete argument;
        *this_ = this;
    }
    inline virtual ~ArgumentVectorType() {}

  private:
    inline void toDest_() {
        if (toDestCustom_ != NULL) {
            std::vector<std::string> arguments;
            if (!empty()) {
                for (std::size_t i = 0; i < size(); ++i) {
                    if (!at(i).empty()) {
                        for (std::size_t j = 0; j < at(i).size(); ++j) {
                            arguments.push_back(at(i).at(j).getString());
                        }
                    }
                    else {
                        arguments.push_back(at(i).getString());
                    }
                }
            }
            else {
                arguments.push_back(argument_);
            }
            toDestCustom_(dest_, isExist_, arguments);
        }
        else {
            if (!empty()) {
                for (std::size_t i = 0; i < size(); ++i) {
                    if (!at(i).empty()) {
                        for (std::size_t j = 0; j < at(i).size(); ++j) {
                            T dest;
                            strTo(at(i).at(j).getString(), dest);
                            dest_.push_back(dest);
                        }
                    }
                    else {
                        T dest;
                        strTo(at(i).getString(), dest);
                        dest_.push_back(dest);
                    }
                }
            }
            else {
                T dest;
                if (type_ == BOOLEAN_OPTION) {
                    boolTo(isExist_, dest);
                }
                else if (type_ == REVERSE_BOOLEAN_OPTION) {
                    boolTo(!isExist_, dest);
                }
                else {
                    strTo(argument_, dest);
                }
                dest_.push_back(dest);
            }
        }
    }

    std::vector<T>& dest_;
    void (*toDestCustom_)(std::vector<T>&, bool, const std::vector<std::string>&);
};

template<typename T>
class ArgumentVectorVectorType : public Argument {
  public:
    inline ArgumentVectorVectorType(Argument* argument, std::vector<std::vector<T> >& dest,
                                    void (*toDest)(std::vector<std::vector<T> >&, bool,
                                                   const std::vector<std::vector<std::string> >&)) :
        Argument(*argument),
        dest_(dest),
        toDestCustom_(toDest) {
        delete argument;
        *this_ = this;
    }
    inline virtual ~ArgumentVectorVectorType() {}

  private:
    inline void toDest_() {
        if (toDestCustom_ != NULL) {
            std::vector<std::vector<std::string> > arguments;
            if (!empty()) {
                for (std::size_t i = 0; i < size(); ++i) {
                    std::vector<std::string> tmpVector;
                    if (!at(i).empty()) {
                        for (std::size_t j = 0; j < at(i).size(); ++j) {
                            tmpVector.push_back(at(i).at(j).getString());
                        }
                    }
                    else {
                        tmpVector.push_back(at(i).getString());
                    }
                    arguments.push_back(tmpVector);
                }
            }
            else {
                std::vector<std::string> tmpVector;
                tmpVector.push_back(argument_);
                arguments.push_back(tmpVector);
            }
            toDestCustom_(dest_, isExist_, arguments);
        }
        else {
            if (!empty()) {
                for (std::size_t i = 0; i < size(); ++i) {
                    std::vector<T> vectorDest;
                    if (!at(i).empty()) {
                        for (std::size_t j = 0; j < at(i).size(); ++j) {
                            T dest;
                            strTo(at(i).at(j).getString(), dest);
                            vectorDest.push_back(dest);
                        }
                    }
                    else {
                        T dest;
                        strTo(at(i).getString(), dest);
                        vectorDest.push_back(dest);
                    }
                    dest_.push_back(vectorDest);
                }
            }
            else {
                T dest;
                if (type_ == BOOLEAN_OPTION) {
                    boolTo(isExist_, dest);
                }
                else if (type_ == REVERSE_BOOLEAN_OPTION) {
                    boolTo(!isExist_, dest);
                }
                else {
                    strTo(argument_, dest);
                }
                std::vector<T> vectorDest;
                vectorDest.push_back(dest);
                dest_.push_back(vectorDest);
            }
        }
    }

    std::vector<std::vector<T> >& dest_;
    void (*toDestCustom_)(std::vector<std::vector<T> >&, bool, const std::vector<std::vector<std::string> >&);
};

} // namespace args

} // namespace blet

#endif // #ifndef BLET_ARGS_ARGUMENT_H_

// --------------------------------
// End include/blet/args/argument.h
// --------------------------------

// #include "blet/args/exception.h" (already included)
// #include "blet/args/usage.h"
// -------------------------------
// Start include/blet/args/usage.h
// -------------------------------

/**
 * args/usage.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2023 BLET Mickaël.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef BLET_ARGS_USAGE_H_
#define BLET_ARGS_USAGE_H_

#include <string>

namespace blet {

namespace args {

class Args;

class Usage {
  public:
    /**
     * @brief Construct a new Usage object
     *
     * @param args
     */
    Usage(Args& args);

    /**
     * @brief Destroy the Usage object
     */
    ~Usage();

    /**
     * @brief Set the usage message
     *
     * @param usage
     */
    inline void setUsage(const char* usage) {
        usage_ = usage;
    }

    /**
     * @brief Get the usage message
     *
     * @return std::string
     */
    std::string getUsage() const;

    /**
     * @brief Set the description in usage message
     *
     * @param description
     */
    inline void setDescription(const char* description) {
        description_ = description;
    }

    /**
     * @brief Get the description message
     *
     * @return const std::string&
     */
    inline const std::string& getDescription() const {
        return description_;
    }

    /**
     * @brief Set the epilog in usage message
     *
     * @param epilog
     */
    inline void setEpilog(const char* epilog) {
        epilog_ = epilog;
    }

    /**
     * @brief Get the epilog message
     *
     * @return const std::string&
     */
    inline const std::string& getEpilog() const {
        return epilog_;
    }

    /**
     * @brief Set the Usage Widths.
     * default values:
     * padWidth: 2,
     * argsWidth: 20,
     * sepWidth: 2,
     * helpWidth: 56
     *
     * @param padWidth width of padding to first column of usage message
     * @param argsWidth width of first column of usage message
     * @param sepWidth width of column separator of usage message
     * @param helpWidth width of second column of usage message
     */
    inline void setUsageWidth(std::size_t padWidth, std::size_t argsWidth, std::size_t sepWidth,
                              std::size_t helpWidth) {
        usagePadWidth_ = padWidth;
        usageArgsWidth_ = argsWidth;
        usageSepWidth_ = sepWidth;
        usageHelpWidth_ = helpWidth;
    }

  protected:
    Args& args_;

    std::string description_;
    std::string epilog_;
    std::string usage_;
    std::size_t usagePadWidth_;
    std::size_t usageArgsWidth_;
    std::size_t usageSepWidth_;
    std::size_t usageHelpWidth_;
};

} // namespace args

} // namespace blet

#endif // #ifndef BLET_ARGS_USAGE_H_

// -----------------------------
// End include/blet/args/usage.h
// -----------------------------

// #include "blet/args/vector.h" (already included)

// --------------------------------
// Content include/blet/args/args.h
// --------------------------------

namespace blet {

namespace args {

class Argument;
class Usage;

/**
 * @brief Object for parse the main arguments
 */
class Args : public Usage {
    friend class Argument;
    friend class Usage;

  public:
    /**
     * @brief Construct a new Args object
     */
    Args(bool addHelp);

    /**
     * @brief Destroy the Args object
     */
    virtual ~Args();

    /**
     * @brief Set the version message
     *
     * @param version
     */
    inline void setVersion(const std::string& version) {
        version_ = version;
    }

    /**
     * @brief Get the version message
     *
     * @return const std::string&
     */
    inline const std::string& getVersion() const {
        return version_;
    }

    /**
     * @brief Activate parsing to accept long option with only one '-' character
     *
     * @param alternivative
     */
    inline Args& setAlternative(bool alternivative = true) {
        isAlternative_ = alternivative;
        return *this;
    }

    /**
     * @brief Get the status of alternative
     *
     * @return [true] at alternative
     */
    inline bool isAlternative() const {
        return isAlternative_;
    }

    /**
     * @brief Activate exception if not all arguments are used; otherwise, you can take additional arguments with
     * getAdditionalArguments method
     *
     * @param strict
     */
    inline Args& setStrict(bool strict = true) {
        isStrict_ = strict;
        return *this;
    }

    /**
     * @brief Get the status of strict
     *
     * @return [true] at strict
     */
    inline bool isStrict() const {
        return isStrict_;
    }

    /**
     * @brief Throw a HelpException when help action is present in arguments; otherwise, exit(0) after outputting usage
     * to stdout
     *
     * @param helpException
     */
    inline Args& setHelpException(bool helpException = true) {
        isHelpException_ = helpException;
        return *this;
    }

    /**
     * @brief Get the status of helpException
     *
     * @return [true] at usage exception
     */
    inline bool isHelpException() const {
        return isHelpException_;
    }

    /**
     * @brief Throw a VersionException when version action is present in arguments; otherwise, exit(0) after outputting
     * version to stdout
     *
     * @param versionException
     */
    inline Args& setVersionException(bool versionException = true) {
        isVersionException_ = versionException;
        return *this;
    }

    /**
     * @brief Get the status of versionException
     *
     * @return [true] at version exception
     */
    inline bool isVersionException() const {
        return isVersionException_;
    }

    /**
     * @brief Set the binary name
     *
     * @param binaryName
     */
    inline void setBinaryName(const char* binaryName) {
        binaryName_ = binaryName;
    }

    /**
     * @brief Get the binary name
     *
     * @return const std::string&
     */
    inline const std::string& getBinaryName() const {
        return binaryName_;
    }

    /**
     * @brief Check if argument exist
     *
     * @param nameOrFlag
     * @return [true] argument is in map, [false] argument is not in map
     */
    inline bool argumentExists(const std::string& nameOrFlag) const {
        return (argumentFromName_.find(nameOrFlag) != argumentFromName_.end());
    }

    /**
     * @brief Get the argument object
     *
     * @param nameOrFlag
     * @return const Argument&
     */
    inline const Argument& getArgument(const std::string& nameOrFlag) const {
        std::map<std::string, Argument**>::const_iterator cit = argumentFromName_.find(nameOrFlag);
        if (cit == argumentFromName_.end()) {
            throw AccessDeniedException(nameOrFlag.c_str(), "argument not found");
        }
        return **(cit->second);
    }

    /**
     * @brief Override bracket operator with getArgument
     *
     * @param nameOrFlag
     * @return const Argument&
     */
    inline const Argument& operator[](const std::string& nameOrFlag) const {
        return getArgument(nameOrFlag);
    }

    /**
     * @brief Get the vector of additional argument
     *
     * @return const std::vector<std::string>&
     */
    inline const std::vector<std::string>& getAdditionalArguments() const {
        return additionalArguments_;
    }

    /**
     * @brief Convert argument strings to objects and assign them as attributes of the args map.
     *        Previous calls to addArgument() determine exactly what objects are created and how they are assigned.
     *        Comportenment depend of setAlternative, setStrict, setHelpException and setVersionException modes.
     * @param argc
     * @param argv
     *
     * @throw HelpException if setHelpException is active
     * @throw VersionException if setVersionException is active
     * @throw ParseArgumentRequiredException
     * @throw ParseArgumentValidException
     * @throw ParseArgumentException
     */
    void parseArguments(int argc, char* argv[]);

    /**
     * @brief Define how a single command-line argument should be parsed
     *
     * @param nameOrFlags Either a name or a list of option strings, e.g. foo or -f, --foo
     *
     * @return Argument& ref of new argument object
     *
     * @throw ArgumentException
     */
    Argument& addArgument(const Vector& nameOrFlags);

    /**
     * @brief Get the ref. of argument from name or flag
     *
     * @param nameOrFlag
     * @return Argument& ref argument object
     *
     * @throw ArgumentException
     */
    inline Argument& updateArgument(const std::string& nameOrFlag) {
        std::map<std::string, Argument**>::iterator it = argumentFromName_.find(nameOrFlag);
        if (it == argumentFromName_.end()) {
            throw AccessDeniedException(nameOrFlag.c_str(), "argument not found");
        }
        return **(it->second);
    }

    /**
     * @brief Remove previously arguments
     *
     * @param nameOrFlags Either a name or a list of option strings, e.g. foo or -f, --foo
     *
     * @throw ArgumentException
     */
    void removeArguments(const Vector& nameOrFlags);

    /**
     * @brief Clear and reset with defaults values
     */
    void clear();

  private:
    Args(const Args&);            // disable copy constructor
    Args& operator=(const Args&); // disable copy operator

    /**
     * @brief Get the short argument decompose multi short argument
     *
     * @param maxIndex
     * @param argv
     * @param index
     */
    void parseShortArgument_(int maxIndex, char* argv[], int* index);

    /**
     * @brief Get the long argument
     *
     * @param maxIndex
     * @param argv
     * @param index
     */
    void parseLongArgument_(int maxIndex, char* argv[], int* index);

    /**
     * @brief Get the argument
     *
     * @param maxIndex
     * @param argv
     * @param index
     * @param hasArg
     * @param option
     * @param arg
     * @param argument
     * @param alternative
     */
    void parseArgument_(int maxIndex, char* argv[], int* index, bool hasArg, const char* option, const char* arg,
                        Argument* argument);

    /**
     * @brief Get the positionnal argument
     *
     * @param argv
     * @param index
     * @param strict
     */
    void parsePositionnalArgument_(int argc, char* argv[], int* index, bool hasEndOption = false);

    /**
     * @brief Check end of infinite parsing
     *
     * @param argument
     * @param alternative
     * @return true
     * @return false
     */
    bool endOfInfiniteArgument_(const char* argument);

    std::string binaryName_;

    std::list<Argument*> arguments_;
    std::map<std::string, Argument**> argumentFromName_;

    Argument* helpOption_;
    Argument* versionOption_;

    std::string version_;

    bool isAlternative_;
    bool isStrict_;
    bool isHelpException_;
    bool isVersionException_;
    std::vector<std::string> additionalArguments_;
};

} // namespace args

} // namespace blet

#endif // #ifndef BLET_ARGS_ARGS_H_

// ----------------------------
// End include/blet/args/args.h
// ----------------------------

// #include "blet/args/exception.h" (already included)
// #include "blet/args/valid.h" (already included)
// #include "blet/args/vector.h" (already included)

// ---------------------------
// Content include/blet/args.h
// ---------------------------

namespace blet {

// simply use args
class Args : public args::Args, public args::Action {
  public:
    inline Args(bool addHelp = true) :
        args::Args(addHelp) {}
    inline ~Args() {}

    typedef args::Exception Exception;
    typedef args::HelpException HelpException;
    typedef args::VersionException VersionException;
    typedef args::ArgumentException ArgumentException;
    typedef args::ParseArgumentException ParseArgumentException;
    typedef args::ParseArgumentRequiredException ParseArgumentRequiredException;
    typedef args::ParseArgumentValidException ParseArgumentValidException;
    typedef args::AccessDeniedException AccessDeniedException;

    typedef args::IValid IValid;
    typedef args::ValidNumber ValidNumber;
    typedef args::ValidChoise ValidChoise;
    typedef args::ValidMinMax ValidMinMax;
    typedef args::ValidPath ValidPath;

    static inline args::Vector vector() {
        return args::Vector();
    }

    static inline args::Vector vector(const char* s1) {
        args::Vector ret(1);
        ret[0] = s1;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2) {
        args::Vector ret(2);
        ret[0] = s1;
        ret[1] = s2;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3) {
        args::Vector ret(3);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4) {
        args::Vector ret(4);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5) {
        args::Vector ret(5);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6) {
        args::Vector ret(6);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7) {
        args::Vector ret(7);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8) {
        args::Vector ret(8);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9) {
        args::Vector ret(9);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10) {
        args::Vector ret(10);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11) {
        args::Vector ret(11);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11, const char* s12) {
        args::Vector ret(12);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        ret[11] = s12;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11, const char* s12, const char* s13) {
        args::Vector ret(13);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        ret[11] = s12;
        ret[12] = s13;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11, const char* s12, const char* s13, const char* s14) {
        args::Vector ret(14);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        ret[11] = s12;
        ret[12] = s13;
        ret[13] = s14;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11, const char* s12, const char* s13, const char* s14,
                                      const char* s15) {
        args::Vector ret(15);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        ret[11] = s12;
        ret[12] = s13;
        ret[13] = s14;
        ret[14] = s15;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11, const char* s12, const char* s13, const char* s14,
                                      const char* s15, const char* s16) {
        args::Vector ret(16);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        ret[11] = s12;
        ret[12] = s13;
        ret[13] = s14;
        ret[14] = s15;
        ret[15] = s16;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11, const char* s12, const char* s13, const char* s14,
                                      const char* s15, const char* s16, const char* s17) {
        args::Vector ret(17);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        ret[11] = s12;
        ret[12] = s13;
        ret[13] = s14;
        ret[14] = s15;
        ret[15] = s16;
        ret[16] = s17;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11, const char* s12, const char* s13, const char* s14,
                                      const char* s15, const char* s16, const char* s17, const char* s18) {
        args::Vector ret(18);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        ret[11] = s12;
        ret[12] = s13;
        ret[13] = s14;
        ret[14] = s15;
        ret[15] = s16;
        ret[16] = s17;
        ret[17] = s18;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11, const char* s12, const char* s13, const char* s14,
                                      const char* s15, const char* s16, const char* s17, const char* s18,
                                      const char* s19) {
        args::Vector ret(19);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        ret[11] = s12;
        ret[12] = s13;
        ret[13] = s14;
        ret[14] = s15;
        ret[15] = s16;
        ret[16] = s17;
        ret[17] = s18;
        ret[18] = s19;
        return ret;
    }

    static inline args::Vector vector(const char* s1, const char* s2, const char* s3, const char* s4, const char* s5,
                                      const char* s6, const char* s7, const char* s8, const char* s9, const char* s10,
                                      const char* s11, const char* s12, const char* s13, const char* s14,
                                      const char* s15, const char* s16, const char* s17, const char* s18,
                                      const char* s19, const char* s20) {
        args::Vector ret(20);
        ret[0] = s1;
        ret[1] = s2;
        ret[2] = s3;
        ret[3] = s4;
        ret[4] = s5;
        ret[5] = s6;
        ret[6] = s7;
        ret[7] = s8;
        ret[8] = s9;
        ret[9] = s10;
        ret[10] = s11;
        ret[11] = s12;
        ret[12] = s13;
        ret[13] = s14;
        ret[14] = s15;
        ret[15] = s16;
        ret[16] = s17;
        ret[17] = s18;
        ret[18] = s19;
        ret[19] = s20;
        return ret;
    }

  private:
    typedef args::Vector Vector;
};

} // namespace blet

#endif // #ifndef BLET_ARGS_H_

// -----------------------
// End include/blet/args.h
// -----------------------

// ------------------
// Start src/args.cpp
// ------------------
/**
 * args.cpp
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2024 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// #include "blet/args/args.h" (already included)

#include <algorithm>
#include <iostream>
#include <sstream>

// #include "blet/args/argument.h" (already included)
// #include "blet/args/utils.h"
// -------------------------------
// Start include/blet/args/utils.h
// -------------------------------

/**
 * args/utils.h
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2023 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef BLET_ARGS_UTILS_H_
#define BLET_ARGS_UTILS_H_

#include <cstring> // strchr
#include <string>

namespace blet {

namespace args {

/**
 * @brief arg is "-[^-].*"
 *
 * @param arg
 * @return true
 * @return false
 */
inline bool isShortOption(const char* arg) {
    if (arg != NULL && arg[0] == '-' && arg[1] != '-' && arg[1] != '\0') {
        return true;
    }
    else {
        return false;
    }
}

/**
 * @brief arg is "--.*"
 *
 * @param arg
 * @return true
 * @return false
 */
inline bool isLongOption(const char* arg) {
    if (arg != NULL && arg[0] == '-' && arg[1] == '-' && arg[2] != '\0') {
        return true;
    }
    else {
        return false;
    }
}

/**
 * @brief arg is "--"
 *
 * @param arg
 * @return true
 * @return false
 */
inline bool isEndOption(const char* arg) {
    if (arg != NULL && arg[0] == '-' && arg[1] == '-' && arg[2] == '\0') {
        return true;
    }
    else {
        return false;
    }
}

/**
 * @brief get index of en option index or argc
 *
 * @param argc
 * @param argv
 * @return int
 */
inline int endOptionIndex(int argc, char** argv) {
    for (int i = 0; i < argc; ++i) {
        if (isEndOption(argv[i])) {
            return i;
        }
    }
    return argc;
}

/**
 * @brief split arg if contain '=' character
 *
 * @param arg
 * @param retOptionName
 * @param retArgument
 * @return true
 * @return false
 */
inline bool takeArg(const char* arg, std::string* retOptionName, std::string* retArgument) {
    char* equal = ::strchr(const_cast<char*>(arg), '=');
    if (equal) {
        std::string firstPart(arg, 0, equal - arg);
        *retOptionName = firstPart;
        std::string secondPart(arg, equal - arg + 1, std::string::npos);
        *retArgument = secondPart;
        return true;
    }
    else {
        *retOptionName = arg;
        return false;
    }
}

} // namespace args

} // namespace blet

#endif // #ifndef BLET_ARGS_UTILS_H_

// -----------------------------
// End include/blet/args/utils.h
// -----------------------------

// #include "blet/args/vector.h" (already included)

// --------------------
// Content src/args.cpp
// --------------------

#define ARGS_PREFIX_SIZEOF_SHORT_OPTION_ (sizeof("-") - 1)
#define ARGS_PREFIX_SIZEOF_LONG_OPTION_ (sizeof("--") - 1)

namespace blet {

namespace args {

inline Args::Args(bool addHelp) :
    Usage(*this),
    binaryName_(),
    arguments_(),
    argumentFromName_(),
    helpOption_(NULL),
    versionOption_(NULL),
    isAlternative_(false),
    isStrict_(false),
    isHelpException_(false),
    isVersionException_(false),
    additionalArguments_() {
    if (addHelp) {
        // define helpOption_
        addArgument("-h").flag("--help").action(Action::HELP).help("show this help message and exit");
    }
}

inline Args::~Args() {
    // delete all new element
    for (std::list<Argument*>::iterator it = arguments_.begin(); it != arguments_.end(); ++it) {
        delete (*it);
    }
}

inline void Args::parseArguments(int argc, char* argv[]) {
    // clear the arguments
    for (std::list<Argument*>::iterator it = arguments_.begin(); it != arguments_.end(); ++it) {
        (*it)->clear_();
    }
    // get argv[0] if filename is empty
    if (binaryName_.empty()) {
        binaryName_ = argv[0];
    }
    // save index of "--" if exist
    int endIndex = endOptionIndex(argc, argv);
    // foreach argument
    for (int i = 1; i < argc; ++i) {
        if (isShortOption(argv[i])) {
            parseShortArgument_(endIndex, argv, &i);
        }
        else if (isLongOption(argv[i])) {
            parseLongArgument_(endIndex, argv, &i);
        }
        else if (isEndOption(argv[i])) {
            ++i;
            while (i < argc) {
                parsePositionnalArgument_(argc, argv, &i, true);
                ++i;
            }
            break;
        }
        else {
            parsePositionnalArgument_(endIndex, argv, &i);
        }
    }
    // check help option
    if (helpOption_ != NULL && helpOption_->isExist_) {
        if (isHelpException_) {
            throw HelpException(getUsage().c_str());
        }
        else {
            std::cout << getUsage() << std::endl;
            clear();
            exit(0);
        }
    }
    // check version option
    if (versionOption_ != NULL && versionOption_->isExist_) {
        if (isVersionException_) {
            throw VersionException(getVersion().c_str());
        }
        else {
            std::cout << getVersion() << std::endl;
            clear();
            exit(0);
        }
    }
    // check require option
    std::list<Argument*>::iterator it;
    for (it = arguments_.begin(); it != arguments_.end(); ++it) {
        if ((*it)->isRequired_ && (*it)->isExist_ == false) {
            if ((*it)->type_ == Argument::POSITIONAL_ARGUMENT) {
                throw ParseArgumentRequiredException((*it)->nameOrFlags_.front().c_str(), "argument is required");
            }
            else {
                throw ParseArgumentRequiredException((*it)->nameOrFlags_.front().c_str(), "option is required");
            }
        }
    }
    // check valid configuration function
    for (it = arguments_.begin(); it != arguments_.end(); ++it) {
        if ((*it)->isExist_ && (*it)->valid_ != NULL) {
            try {
                std::vector<std::string> arguments;
                switch ((*it)->type_) {
                    case Argument::POSITIONAL_ARGUMENT:
                    case Argument::NUMBER_POSITIONAL_ARGUMENT:
                    case Argument::INFINITE_POSITIONAL_ARGUMENT:
                    case Argument::INFINITE_NUMBER_POSITIONAL_ARGUMENT:
                    case Argument::SIMPLE_OPTION:
                    case Argument::NUMBER_OPTION:
                    case Argument::MULTI_OPTION:
                    case Argument::INFINITE_OPTION:
                    case Argument::MULTI_INFINITE_OPTION:
                    case Argument::MULTI_NUMBER_OPTION:
                    case Argument::MULTI_NUMBER_INFINITE_OPTION: {
                        const Argument& cArg = *(*it);
                        arguments = cArg.operator std::vector<std::string>();
                        break;
                    }
                    default:
                        break;
                }
                if ((*it)->valid_->isValid(arguments) == false) {
                    throw ParseArgumentValidException("invalid check function");
                }
                switch ((*it)->type_) {
                    case Argument::POSITIONAL_ARGUMENT:
                    case Argument::SIMPLE_OPTION:
                        if (!arguments.empty()) {
                            (*it)->argument_ = arguments.front();
                        }
                        break;
                    case Argument::NUMBER_OPTION:
                    case Argument::MULTI_OPTION:
                    case Argument::INFINITE_OPTION:
                    case Argument::MULTI_INFINITE_OPTION:
                    case Argument::NUMBER_POSITIONAL_ARGUMENT:
                    case Argument::INFINITE_POSITIONAL_ARGUMENT:
                        for (std::size_t i = 0; i < (*it)->size() && i < arguments.size(); ++i) {
                            (*it)->at(i).argument_ = arguments[i];
                        }
                        break;
                    case Argument::MULTI_NUMBER_OPTION:
                    case Argument::MULTI_NUMBER_INFINITE_OPTION:
                    case Argument::INFINITE_NUMBER_POSITIONAL_ARGUMENT: {
                        std::size_t i = 0;
                        for (std::size_t j = 0; j < (*it)->size() && i < arguments.size(); ++j) {
                            for (std::size_t k = 0; k < (*it)->at(j).size() && i < arguments.size(); ++k) {
                                (*it)->at(j).at(k).argument_ = arguments[i];
                                ++i;
                            }
                        }
                        break;
                    }
                    default:
                        throw ParseArgumentValidException("invalid type option for use valid");
                        break;
                }
            }
            catch (const ParseArgumentValidException& e) {
                // add name or first flag in exception
                throw ParseArgumentValidException((*it)->nameOrFlags_.front().c_str(), e.what());
            }
        }
        // tranform argument to number
        (*it)->toNumber_();
        // dest
        (*it)->toDest_();
    }
}

inline Argument& Args::addArgument(const Vector& nameOrFlags) {
    if (nameOrFlags.empty()) {
        throw ArgumentException("", "invalid empty flag");
    }
    Argument* argument = NULL;
    // is name
    if (nameOrFlags.size() == 1 && nameOrFlags.front()[0] != '-') {
        if (nameOrFlags.front().empty()) {
            throw ArgumentException("", "bad name argument");
        }
        if (argumentFromName_.find(nameOrFlags.front()) != argumentFromName_.end()) {
            throw ArgumentException(nameOrFlags.front().c_str(), "bad name argument already exist");
        }
        // create argument
        argument = new Argument(*this);
        argument->nameOrFlags_.push_back(nameOrFlags.front());
        argument->nargs_ = 1;
        argument->type_ = Argument::POSITIONAL_ARGUMENT;
    }
    else {
        std::vector<std::string> newFlags;

        for (std::size_t i = 0; i < nameOrFlags.size(); ++i) {
            Argument::validFormatFlag_(nameOrFlags[i].c_str());
            if (argumentFromName_.find(nameOrFlags.front()) != argumentFromName_.end()) {
                throw ArgumentException(nameOrFlags.front().c_str(), "invalid flag already exist");
            }
            if (std::find(newFlags.begin(), newFlags.end(), nameOrFlags[i]) == newFlags.end()) {
                newFlags.push_back(nameOrFlags[i]);
            }
        }

        argument = new Argument(*this);
        argument->nameOrFlags_ = nameOrFlags;
        argument->sortNameOrFlags_();
    }

    arguments_.push_back(argument);
    Argument** addrNewArgument = &(arguments_.back());
    argument->this_ = addrNewArgument;
    for (std::size_t i = 0; i < argument->nameOrFlags_.size(); ++i) {
        argumentFromName_.insert(std::pair<std::string, Argument**>(argument->nameOrFlags_[i], addrNewArgument));
    }
    arguments_.sort(&Argument::compareOption_);
    return **addrNewArgument;
}

inline void Args::removeArguments(const Vector& nameOrFlags) {
    if (nameOrFlags.empty()) {
        throw ArgumentException("", "invalid empty flag");
    }
    std::vector<std::map<std::string, Argument**>::iterator> vIt;
    // check if all element is exists and store iterator
    for (std::size_t i = 0; i < nameOrFlags.size(); ++i) {
        std::map<std::string, Argument**>::iterator it = argumentFromName_.find(nameOrFlags[i]);
        if (it == argumentFromName_.end()) {
            throw ArgumentException(nameOrFlags[i].c_str(), "argument not found");
        }
        vIt.push_back(it);
    }
    for (std::size_t i = 0; i < vIt.size(); ++i) {
        Argument** ppArgument = vIt[i]->second;
        // remove name or flag in argument object
        std::vector<std::string>::iterator namesIt =
            std::find((*ppArgument)->nameOrFlags_.begin(), (*ppArgument)->nameOrFlags_.end(), vIt[i]->first);
        (*ppArgument)->nameOrFlags_.erase(namesIt);
        // remove argument
        argumentFromName_.erase(vIt[i]);
        // check if ppArgument not exists
        std::map<std::string, Argument**>::iterator it = argumentFromName_.begin();
        for (it = argumentFromName_.begin(); it != argumentFromName_.end(); ++it) {
            if (it->second == ppArgument) {
                break;
            }
        }
        // remove from argument list
        if (it == argumentFromName_.end()) {
            std::list<Argument*>::iterator aIt = std::find(arguments_.begin(), arguments_.end(), *ppArgument);
            if (*aIt == helpOption_) {
                helpOption_ = NULL;
            }
            else if (*aIt == versionOption_) {
                versionOption_ = NULL;
            }
            delete (*aIt);
            arguments_.erase(aIt);
        }
        else {
            (**it->second).sortNameOrFlags_();
        }
    }
    arguments_.sort(&Argument::compareOption_);
}

inline void Args::clear() {
    // delete all new element
    for (std::list<Argument*>::iterator it = arguments_.begin(); it != arguments_.end(); ++it) {
        delete (*it);
    }
    arguments_.clear();
    argumentFromName_.clear();
    binaryName_ = "";
    helpOption_ = NULL;
    versionOption_ = NULL;
    version_ = "";
    isAlternative_ = false;
    isStrict_ = false;
    isHelpException_ = false;
    isVersionException_ = false;
    additionalArguments_.clear();
    // usage
    description_ = "";
    epilog_ = "";
    usage_ = "";
    usagePadWidth_ = 2;
    usageArgsWidth_ = 20;
    usageSepWidth_ = 2;
    usageHelpWidth_ = 56;
}

/*
** private
*/
inline void Args::parseShortArgument_(int maxIndex, char* argv[], int* index) {
    std::string options;
    std::string arg;
    std::map<std::string, Argument**>::iterator it;
    bool hasArg = takeArg(argv[*index], &options, &arg);
    if (isAlternative_) {
        // try to find long option
        it = argumentFromName_.find("-" + options);
        if (it != argumentFromName_.end()) {
            parseArgument_(maxIndex, argv, index, hasArg, options.c_str() + ARGS_PREFIX_SIZEOF_SHORT_OPTION_,
                           arg.c_str(), *(it->second));
            return;
        }
    }
    // get firsts option
    for (std::size_t i = 1; i < options.size() - 1; ++i) {
        std::string charOption(options, i, 1);
        it = argumentFromName_.find("-" + charOption);
        if (it == argumentFromName_.end()) {
            throw ParseArgumentException(charOption.c_str(), "invalid option");
        }
        else if (!hasArg && ((*(it->second))->type_ == Argument::SIMPLE_OPTION ||
                             (*(it->second))->type_ == Argument::NUMBER_OPTION ||
                             (*(it->second))->type_ == Argument::INFINITE_OPTION ||
                             (*(it->second))->type_ == Argument::MULTI_OPTION ||
                             (*(it->second))->type_ == Argument::MULTI_INFINITE_OPTION ||
                             (*(it->second))->type_ == Argument::MULTI_NUMBER_OPTION)) {
            hasArg = true;
            arg = options.substr(i + 1, options.size() - i);
            (*(it->second))->isExist_ = true;
            ++(*(it->second))->count_;
            parseArgument_(maxIndex, argv, index, hasArg, charOption.c_str(), arg.c_str(), *(it->second));
            return;
        }
        else if ((*(it->second))->type_ != Argument::BOOLEAN_OPTION &&
                 (*(it->second))->type_ != Argument::REVERSE_BOOLEAN_OPTION) {
            throw ParseArgumentException(charOption.c_str(), "only last option can be use a parameter");
        }
        (*(it->second))->isExist_ = true;
        ++(*(it->second))->count_;
    }
    // get last option
    std::string charOption(options, options.size() - 1, 1);
    it = argumentFromName_.find("-" + charOption);
    if (it == argumentFromName_.end()) {
        throw ParseArgumentException(charOption.c_str(), "invalid option");
    }
    parseArgument_(maxIndex, argv, index, hasArg, charOption.c_str(), arg.c_str(), *(it->second));
}

inline void Args::parseLongArgument_(int maxIndex, char* argv[], int* index) {
    std::string option;
    std::string arg;
    std::map<std::string, Argument**>::iterator it;
    bool hasArg = takeArg(argv[*index], &option, &arg);
    it = argumentFromName_.find(option);
    if (it == argumentFromName_.end()) {
        throw ParseArgumentException(option.c_str() + ARGS_PREFIX_SIZEOF_LONG_OPTION_, "invalid option");
    }
    parseArgument_(maxIndex, argv, index, hasArg, option.c_str() + ARGS_PREFIX_SIZEOF_LONG_OPTION_, arg.c_str(),
                   *(it->second));
}

inline void Args::parseArgument_(int maxIndex, char* argv[], int* index, bool hasArg, const char* option,
                                 const char* arg, Argument* argument) {
    if (hasArg) {
        switch (argument->type_) {
            case Argument::SIMPLE_OPTION:
                argument->argument_ = arg;
                break;
            case Argument::NUMBER_OPTION:
            case Argument::MULTI_NUMBER_OPTION:
            case Argument::MULTI_NUMBER_INFINITE_OPTION:
                throw ParseArgumentException(option, "option cannot use with only 1 argument");
                break;
            case Argument::INFINITE_OPTION: {
                argument->clear();
                argument->push_back(arg);
                break;
            }
            case Argument::MULTI_OPTION:
            case Argument::MULTI_INFINITE_OPTION: {
                if (argument->isExist_ == false) {
                    argument->clear();
                }
                argument->push_back(arg);
                break;
            }
            default:
                throw ParseArgumentException(option, "option cannot use with argument");
                break;
        }
    }
    else {
        switch (argument->type_) {
            case Argument::SIMPLE_OPTION:
                if (*index + 1 >= maxIndex) {
                    throw ParseArgumentException(option, "bad number of argument");
                }
                ++(*index);
                argument->argument_ = argv[*index];
                break;
            case Argument::NUMBER_OPTION:
                argument->clear();
                if (*index + argument->nargs_ >= static_cast<unsigned int>(maxIndex)) {
                    throw ParseArgumentException(option, "bad number of argument");
                }
                for (unsigned int i = *index + 1; i <= (*index + argument->nargs_); ++i) {
                    argument->push_back(argv[i]);
                }
                *index += argument->nargs_;
                break;
            case Argument::INFINITE_OPTION: {
                argument->clear();
                std::size_t countArg = 0;
                for (int i = *index + 1; i < maxIndex; ++i) {
                    if (endOfInfiniteArgument_(argv[i])) {
                        break;
                    }
                    argument->push_back(argv[i]);
                    ++countArg;
                }
                *index += countArg;
                break;
            }
            case Argument::MULTI_OPTION: {
                if (argument->isExist_ == false) {
                    argument->clear();
                }
                if (*index + 1 >= maxIndex) {
                    throw ParseArgumentException(option, "bad number of argument");
                }
                ++(*index);
                argument->push_back(argv[*index]);
                break;
            }
            case Argument::MULTI_INFINITE_OPTION: {
                if (argument->isExist_ == false) {
                    argument->clear();
                }
                std::size_t countArg = 0;
                for (int i = *index + 1; i < maxIndex; ++i) {
                    if (endOfInfiniteArgument_(argv[i])) {
                        break;
                    }
                    argument->push_back(argv[i]);
                    ++countArg;
                }
                *index += countArg;
                break;
            }
            case Argument::MULTI_NUMBER_OPTION: {
                if (argument->isExist_ == false) {
                    argument->clear();
                }
                if (*index + argument->nargs_ >= static_cast<unsigned int>(maxIndex)) {
                    throw ParseArgumentException(option, "bad number of argument");
                }
                ArgumentElement newNumberArgument;
                for (unsigned int i = *index + 1; i <= *index + argument->nargs_; ++i) {
                    newNumberArgument.push_back(argv[i]);
                }
                argument->push_back(newNumberArgument);
                *index += argument->nargs_;
                break;
            }
            case Argument::MULTI_NUMBER_INFINITE_OPTION: {
                if (argument->isExist_ == false) {
                    argument->clear();
                }
                std::size_t countArg = 0;
                for (int i = *index + 1; i < maxIndex; i += argument->nargs_) {
                    if (endOfInfiniteArgument_(argv[i])) {
                        break;
                    }
                    if (i + argument->nargs_ > static_cast<unsigned int>(maxIndex)) {
                        throw ParseArgumentException(option, "bad number of argument");
                    }
                    ArgumentElement newNumberArgument;
                    for (unsigned int j = i; j < i + argument->nargs_; ++j) {
                        newNumberArgument.push_back(argv[j]);
                        ++countArg;
                    }
                    argument->push_back(newNumberArgument);
                }
                *index += countArg;
                break;
            }
            default:
                break;
        }
    }
    argument->isExist_ = true;
    ++argument->count_;
}

inline bool Args::endOfInfiniteArgument_(const char* argument) {
    std::string option;
    std::string arg;
    std::map<std::string, Argument**>::iterator it;
    if (isShortOption(argument)) {
        bool hasArg = takeArg(argument, &option, &arg);
        if (isAlternative_) {
            it = argumentFromName_.find("-" + option);
            if (it != argumentFromName_.end()) {
                return true;
            }
        }
        // get firsts option
        for (std::size_t i = 1; i < option.size() - 1; ++i) {
            std::string charOption(option, i, 1);
            it = argumentFromName_.find("-" + charOption);
            if (it == argumentFromName_.end()) {
                return false;
            }
            else if (!hasArg && ((*(it->second))->type_ == Argument::SIMPLE_OPTION ||
                                 (*(it->second))->type_ == Argument::NUMBER_OPTION ||
                                 (*(it->second))->type_ == Argument::INFINITE_OPTION ||
                                 (*(it->second))->type_ == Argument::MULTI_OPTION ||
                                 (*(it->second))->type_ == Argument::MULTI_INFINITE_OPTION ||
                                 (*(it->second))->type_ == Argument::MULTI_NUMBER_OPTION)) {
                return true;
            }
            else if ((*(it->second))->type_ == Argument::BOOLEAN_OPTION ||
                     (*(it->second))->type_ == Argument::REVERSE_BOOLEAN_OPTION) {
                return true;
            }
        }
        // get last option
        std::string charOption(option, option.size() - 1, 1);
        it = argumentFromName_.find("-" + charOption);
    }
    else if (isLongOption(argument)) {
        takeArg(argument, &option, &arg);
        it = argumentFromName_.find(option);
    }
    else {
        return false;
    }
    if (it == argumentFromName_.end()) {
        return false;
    }
    return true;
}

inline void Args::parsePositionnalArgument_(int argc, char* argv[], int* index, bool hasEndOption) {
    // find not exists positionnal argument
    std::list<Argument*>::iterator it;
    for (it = arguments_.begin(); it != arguments_.end(); ++it) {
        if ((*it)->isExist_ == false && (*it)->isPositionnalArgument_()) {
            break;
        }
    }
    if (it != arguments_.end()) {
        Argument& argument = *(*it);
        if (argument.type_ == Argument::POSITIONAL_ARGUMENT) {
            argument.argument_ = argv[*index];
        }
        else if (argument.type_ == Argument::NUMBER_POSITIONAL_ARGUMENT) {
            if (*index + argument.nargs_ > static_cast<unsigned int>(argc)) {
                throw ParseArgumentException(argument.nameOrFlags_.front().c_str(), "bad number of argument");
            }
            for (unsigned int i = *index; i < (*index + argument.nargs_); ++i) {
                argument.push_back(argv[i]);
            }
            *index += argument.nargs_ - 1;
        }
        else if (argument.type_ == Argument::INFINITE_POSITIONAL_ARGUMENT) {
            std::size_t countArg = 0;
            for (int i = *index; i < argc; ++i) {
                if (!hasEndOption && endOfInfiniteArgument_(argv[i])) {
                    break;
                }
                (*it)->push_back(argv[i]);
                ++countArg;
            }
            *index += countArg - 1;
        }
        else if (argument.type_ == Argument::INFINITE_NUMBER_POSITIONAL_ARGUMENT) {
            std::size_t countArg = 0;
            for (int i = *index; i < argc; i += argument.nargs_) {
                if (!hasEndOption && endOfInfiniteArgument_(argv[i])) {
                    break;
                }
                if (i + argument.nargs_ > static_cast<unsigned int>(argc)) {
                    throw ParseArgumentException(argument.nameOrFlags_.front().c_str(), "bad number of argument");
                }
                ArgumentElement newNumberArgument;
                for (unsigned int j = i; j < i + argument.nargs_; ++j) {
                    newNumberArgument.push_back(argv[j]);
                    ++countArg;
                }
                argument.push_back(newNumberArgument);
            }
            *index += countArg - 1;
        }
        argument.isExist_ = true;
    }
    else {
        if (isStrict_) {
            throw ParseArgumentException(argv[*index], "invalid additional argument");
        }
        else {
            additionalArguments_.push_back(argv[*index]);
        }
    }
}

} // namespace args

} // namespace blet

#undef ARGS_PREFIX_SIZEOF_SHORT_OPTION_
#undef ARGS_PREFIX_SIZEOF_LONG_OPTION_

// ----------------
// End src/args.cpp
// ----------------

// ----------------------
// Start src/argument.cpp
// ----------------------
/**
 * argument.cpp
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2024 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// #include "blet/args/argument.h" (already included)

#include <algorithm>
#include <sstream>

// #include "blet/args/action.h" (already included)
// #include "blet/args/args.h" (already included)
// #include "blet/args/utils.h" (already included)

#define ARGS_PREFIX_SIZEOF_SHORT_OPTION_ (sizeof("-") - 1)
#define ARGS_PREFIX_SIZEOF_LONG_OPTION_ (sizeof("--") - 1)

namespace blet {

namespace args {

static inline bool compareFlag(const std::string& first, const std::string& second) {
    if (isShortOption(first.c_str()) && isShortOption(second.c_str())) {
        return first < second;
    }
    else if (isShortOption(first.c_str()) && !isShortOption(second.c_str())) {
        return true;
    }
    else if (!isShortOption(first.c_str()) && isShortOption(second.c_str())) {
        return false;
    }
    else {
        return first < second;
    }
}

/*
################################################################################
 ArgumentElement
################################################################################
*/

inline ArgumentElement::ArgumentElement() :
    std::vector<ArgumentElement>(),
    argument_(),
    default_(),
    isNumber_(false),
    number_(0.0) {}
inline ArgumentElement::ArgumentElement(const ArgumentElement& rhs) :
    std::vector<ArgumentElement>(rhs),
    argument_(rhs.argument_),
    default_(rhs.default_),
    isNumber_(rhs.isNumber_),
    number_(rhs.number_) {}
inline ArgumentElement::ArgumentElement(const char* arg__, const char* default__) :
    std::vector<ArgumentElement>(),
    argument_(arg__),
    default_(default__),
    isNumber_(false),
    number_(0.0) {}
inline ArgumentElement::ArgumentElement(const char* arg) :
    std::vector<ArgumentElement>(),
    argument_(arg),
    default_(),
    isNumber_(false),
    number_(0.0) {}
inline ArgumentElement::~ArgumentElement() {}

inline ArgumentElement::operator std::vector<std::string>() const {
    if (!empty() && front().empty()) {
        std::vector<std::string> ret;
        for (std::size_t i = 0; i < size(); ++i) {
            ret.push_back(at(i).argument_);
        }
        return ret;
    }
    throw Exception("convertion to vector of string not authorized");
}

/*
################################################################################
 Argument
################################################################################
*/

inline Argument::Argument(Args& args) :
    ArgumentElement(),
    args_(args),
    nameOrFlags_(),
    type_(SIMPLE_OPTION),
    isExist_(false),
    isRequired_(false),
    count_(0),
    nargs_(1),
    help_(),
    metavar_(),
    valid_(NULL),
    validDeletable_(true),
    this_(NULL),
    action_(Action::NONE),
    defaults_() {}

inline Argument::Argument(const Argument& rhs) :
    ArgumentElement(rhs),
    args_(rhs.args_),
    nameOrFlags_(rhs.nameOrFlags_),
    type_(rhs.type_),
    isExist_(rhs.isExist_),
    isRequired_(rhs.isRequired_),
    count_(rhs.count_),
    nargs_(rhs.nargs_),
    help_(rhs.help_),
    metavar_(rhs.metavar_),
    valid_(rhs.valid_),
    validDeletable_(rhs.validDeletable_),
    this_(rhs.this_),
    action_(rhs.action_),
    defaults_() {}

inline Argument::~Argument() {
    if (valid_ != NULL && validDeletable_) {
        delete valid_;
    }
}

inline std::string Argument::getString() const {
    std::string ret("");
    if (type_ == BOOLEAN_OPTION) {
        ret = (isExist_) ? "true" : "false";
    }
    else if (type_ == REVERSE_BOOLEAN_OPTION) {
        ret = (isExist_) ? "false" : "true";
    }
    else {
        std::ostringstream oss("");
        if (!empty()) {
            for (std::size_t i = 0; i < size(); ++i) {
                if (i > 0) {
                    oss << ", ";
                }
                if (!at(i).empty()) {
                    oss << "(";
                    for (std::size_t j = 0; j < at(i).size(); ++j) {
                        if (j > 0) {
                            oss << ", ";
                        }
                        oss << at(i).at(j).argument_;
                    }
                    oss << ")";
                }
                else {
                    oss << at(i).argument_;
                }
            }
        }
        else {
            oss << argument_;
        }
        ret = oss.str();
    }
    return ret;
}

inline Argument::operator std::vector<std::string>() const {
    std::vector<std::string> ret;
    switch (type_) {
        case POSITIONAL_ARGUMENT:
        case SIMPLE_OPTION:
            ret.push_back(argument_);
            break;
        case NUMBER_POSITIONAL_ARGUMENT:
        case INFINITE_POSITIONAL_ARGUMENT:
        case NUMBER_OPTION:
        case MULTI_OPTION:
        case INFINITE_OPTION:
        case MULTI_INFINITE_OPTION:
            for (std::size_t i = 0; i < size(); ++i) {
                ret.push_back(at(i).argument_);
            }
            break;
        case MULTI_NUMBER_OPTION:
        case MULTI_NUMBER_INFINITE_OPTION:
        case INFINITE_NUMBER_POSITIONAL_ARGUMENT:
            for (std::size_t i = 0; i < size(); ++i) {
                for (std::size_t j = 0; j < at(i).size(); ++j) {
                    ret.push_back(at(i).at(j).argument_);
                }
            }
            break;
        default:
            throw Exception("convertion to vector of string not authorized");
            break;
    }
    return ret;
}

inline Argument::operator std::vector<std::vector<std::string> >() const {
    std::vector<std::vector<std::string> > ret;
    switch (type_) {
        case MULTI_NUMBER_OPTION:
        case MULTI_NUMBER_INFINITE_OPTION:
        case INFINITE_NUMBER_POSITIONAL_ARGUMENT:
            for (std::size_t i = 0; i < size(); ++i) {
                ret.push_back(std::vector<std::string>());
                for (std::size_t j = 0; j < at(i).size(); ++j) {
                    ret[i].push_back(at(i).at(j).argument_);
                }
            }
            break;
        default:
            throw Exception("convertion to vector of vector of string not authorized");
            break;
    }
    return ret;
}

inline Argument& Argument::flag(const char* flag__) {
    if (isPositionnalArgument_()) {
        throw ArgumentException(flag__, "can't add flag in positionnal argument");
    }
    validFormatFlag_(flag__);
    if (args_.argumentExists(flag__)) {
        throw ArgumentException(flag__, "invalid flag already exist");
    }
    nameOrFlags_.push_back(flag__);
    sortNameOrFlags_();
    args_.argumentFromName_.insert(std::pair<std::string, Argument**>(flag__, this_));
    args_.arguments_.sort(&Argument::compareOption_);
    return *this;
}

inline Argument& Argument::action(enum Action::eAction action__) {
    // reset help option
    if (action_ == Action::HELP) {
        args_.helpOption_ = NULL;
    }
    // reset version option
    if (action_ == Action::VERSION) {
        args_.versionOption_ = NULL;
    }
    action_ = action__;
    typeConstructor_();
    defaultsConstructor_();
    return *this;
}

inline Argument& Argument::required(bool required__) {
    isRequired_ = required__;
    args_.arguments_.sort(&Argument::compareOption_);
    return *this;
}

inline void Argument::sortNameOrFlags_() {
    std::sort(nameOrFlags_.begin(), nameOrFlags_.end(), &compareFlag);
}

inline void Argument::validFormatFlag_(const char* flag) {
    if (flag[0] != '-') {
        throw ArgumentException(flag, "invalid flag not start by '-' character");
    }
    if (flag[0] == '-' && flag[1] == '\0') {
        throw ArgumentException(flag, "invalid flag not be only '-' character");
    }
    if (flag[0] == '-' && flag[1] == '-' && flag[2] == '\0') {
        throw ArgumentException(flag, "invalid flag not be only '--' characters");
    }
    if (flag[0] == '-' && flag[1] != '-' && flag[2] != '\0') {
        throw ArgumentException(flag, "invalid short flag has not only one character");
    }
}

inline bool Argument::compareOption_(const Argument* first, const Argument* second) {
    if (first->isPositionnalArgument_() && first->isRequired_ && second->isPositionnalArgument_() &&
        second->isRequired_) {
        return false;
    }
    else if (first->isPositionnalArgument_() && first->isRequired_ && second->isPositionnalArgument_()) {
        return true;
    }
    else if (first->isPositionnalArgument_() && second->isPositionnalArgument_() && second->isRequired_) {
        return false;
    }
    else if (first->isPositionnalArgument_() && second->isPositionnalArgument_()) {
        return false;
    }
    else if (first->isPositionnalArgument_()) {
        return false;
    }
    else if (second->isPositionnalArgument_()) {
        return true;
    }
    if (isShortOption(first->nameOrFlags_.front().c_str()) && isShortOption(second->nameOrFlags_.front().c_str())) {
        if (first->isRequired_ && !second->isRequired_) {
            return true;
        }
        else if (!first->isRequired_ && second->isRequired_) {
            return false;
        }
        else {
            return first->nameOrFlags_.front() < second->nameOrFlags_.front();
        }
    }
    else if (isShortOption(first->nameOrFlags_.front().c_str()) &&
             !isShortOption(second->nameOrFlags_.front().c_str())) {
        /*
        if (first->isRequired_ && !second->isRequired_) {
            return true;
        }
        else
        */
        if (!first->isRequired_ && second->isRequired_) {
            return false;
        }
        else {
            return true;
        }
    }
    else if (!isShortOption(first->nameOrFlags_.front().c_str()) &&
             isShortOption(second->nameOrFlags_.front().c_str())) {
        if (first->isRequired_ && !second->isRequired_) {
            return true;
        }
        else if (!first->isRequired_ && second->isRequired_) {
            return false;
        }
        else {
            return false;
        }
    }
    else {
        if (first->isRequired_ && !second->isRequired_) {
            return true;
        }
        else if (!first->isRequired_ && second->isRequired_) {
            return false;
        }
        return first->nameOrFlags_.front() < second->nameOrFlags_.front();
    }
}

inline void Argument::toNumber_() {
    if (type_ == BOOLEAN_OPTION || type_ == REVERSE_BOOLEAN_OPTION) {
        return;
    }
    else {
        if (!empty()) {
            for (std::size_t i = 0; i < size(); ++i) {
                if (!at(i).empty()) {
                    for (std::size_t j = 0; j < at(i).size(); ++j) {
                        std::stringstream ss(at(i).at(j).argument_);
                        at(i).at(j).isNumber_ = static_cast<bool>(ss >> at(i).at(j).number_);
                    }
                }
                else {
                    std::stringstream ss(at(i).argument_);
                    at(i).isNumber_ = static_cast<bool>(ss >> at(i).number_);
                }
            }
        }
        else {
            std::stringstream ss(argument_);
            isNumber_ = static_cast<bool>(ss >> number_);
        }
    }
}

inline std::string Argument::metavarDefault_() {
    const char* flag = NULL;
    // get short or long name
    for (std::size_t i = 0; i < nameOrFlags_.size(); ++i) {
        if (nameOrFlags_[i][0] == '-' && nameOrFlags_[i][1] == '-') {
            flag = nameOrFlags_[i].c_str() + ARGS_PREFIX_SIZEOF_LONG_OPTION_;
            break;
        }
        else if (flag == NULL && nameOrFlags_[i][0] == '-' && nameOrFlags_[i][1] != '-') {
            flag = nameOrFlags_[i].c_str() + ARGS_PREFIX_SIZEOF_SHORT_OPTION_;
        }
    }
    // create a defaultUsageName from longName or shortName
    std::string defaultUsageName = flag;
    for (std::size_t i = 0; i < defaultUsageName.size(); ++i) {
        defaultUsageName[i] = ::toupper(defaultUsageName[i]);
    }

    if (action_ == Action::INFINITE || nargs_ == '+') {
        return defaultUsageName + "...";
    }
    else if (nargs_ > 1) {
        std::string numberDefaultUsageName;
        for (std::size_t i = 0; i < nargs_; ++i) {
            if (i > 0) {
                numberDefaultUsageName += " ";
            }
            numberDefaultUsageName += defaultUsageName;
        }
        return numberDefaultUsageName;
    }
    else {
        return defaultUsageName;
    }
}

inline void Argument::typeConstructor_() {
    if (isPositionnalArgument_()) {
        if (nargs_ == 1 && action_ == Action::NONE) {
            type_ = Argument::POSITIONAL_ARGUMENT;
        }
        else if ((nargs_ == '+' && action_ == Action::NONE) || (nargs_ == 1 && action_ == Action::INFINITE)) {
            nargs_ = 1;
            action_ = Action::INFINITE;
            type_ = Argument::INFINITE_POSITIONAL_ARGUMENT;
        }
        else if (nargs_ > 1 && action_ == Action::NONE) {
            type_ = Argument::NUMBER_POSITIONAL_ARGUMENT;
        }
        else if (nargs_ > 1 && action_ == Action::INFINITE) {
            type_ = Argument::INFINITE_NUMBER_POSITIONAL_ARGUMENT;
        }
        else {
            throw ArgumentException(nameOrFlags_.front().c_str(),
                                    "positional argument cannot use with this action or this nargs");
        }
    }
    else if (nargs_ == 0 || action_ == Action::STORE_TRUE) {
        nargs_ = 0;
        type_ = Argument::BOOLEAN_OPTION;
    }
    else if (action_ == Action::STORE_FALSE) {
        nargs_ = 0;
        type_ = Argument::REVERSE_BOOLEAN_OPTION;
    }
    else if (action_ == Action::HELP) {
        if (args_.helpOption_ == NULL) {
            args_.helpOption_ = this;
        }
        if (args_.helpOption_ != NULL && args_.helpOption_ != this) {
            throw ArgumentException(nameOrFlags_.front().c_str(), "help action already defined");
        }
        nargs_ = 0;
        type_ = Argument::HELP_OPTION;
    }
    else if (action_ == Action::VERSION) {
        if (args_.versionOption_ == NULL) {
            args_.versionOption_ = this;
        }
        if (args_.versionOption_ != NULL && args_.versionOption_ != this) {
            throw ArgumentException(nameOrFlags_.front().c_str(), "version action already defined");
        }
        nargs_ = 0;
        type_ = Argument::VERSION_OPTION;
    }
    // is simple
    else if (nargs_ == 1 && action_ == Action::NONE) {
        type_ = Argument::SIMPLE_OPTION;
    }
    // is infinite
    else if ((nargs_ == '+' && action_ == Action::NONE) || action_ == Action::INFINITE) {
        nargs_ = 1;
        action_ = Action::INFINITE;
        type_ = Argument::INFINITE_OPTION;
    }
    // is number
    else if (nargs_ > 1 && action_ == Action::NONE) {
        type_ = Argument::NUMBER_OPTION;
    }
    // is multi
    else if (nargs_ == 1 && action_ == Action::APPEND) {
        type_ = Argument::MULTI_OPTION;
    }
    // is multi number
    else if (nargs_ > 1 && action_ == Action::APPEND) {
        type_ = Argument::MULTI_NUMBER_OPTION;
    }
    // is multi infinite
    else if (nargs_ == 1 && action_ == Action::EXTEND) {
        type_ = Argument::MULTI_INFINITE_OPTION;
    }
    // is multi number infinite
    else if (nargs_ > 1 && action_ == Action::EXTEND) {
        type_ = Argument::MULTI_NUMBER_INFINITE_OPTION;
    }
}

inline void Argument::defaultsConstructor_() {
    // default arguments
    if (nargs_ > 0 && defaults_.size() > 0) {
        clear();
        if (type_ == Argument::POSITIONAL_ARGUMENT || type_ == Argument::SIMPLE_OPTION) {
            if (defaults_.size() != nargs_) {
                throw ArgumentException(nameOrFlags_.front().c_str(),
                                        "invalid number of argument with number of default argument");
            }
            argument_ = defaults_.front();
            default_ = defaults_.front();
        }
        if (type_ == Argument::NUMBER_POSITIONAL_ARGUMENT || type_ == Argument::NUMBER_OPTION) {
            if (defaults_.size() != nargs_) {
                throw ArgumentException(nameOrFlags_.front().c_str(),
                                        "invalid number of argument with number of default argument");
            }
            default_ = "";
            for (std::size_t i = 0; i < defaults_.size(); ++i) {
                if (i > 0) {
                    default_ += ", ";
                }
                default_ += defaults_[i];
                push_back(ArgumentElement(defaults_[i].c_str(), defaults_[i].c_str()));
            }
        }
        if (type_ == Argument::INFINITE_POSITIONAL_ARGUMENT || type_ == Argument::MULTI_OPTION ||
            type_ == Argument::INFINITE_OPTION || type_ == Argument::MULTI_INFINITE_OPTION) {
            default_ = "";
            for (std::size_t i = 0; i < defaults_.size(); ++i) {
                if (i > 0) {
                    default_ += ", ";
                }
                default_ += defaults_[i];
                push_back(ArgumentElement(defaults_[i].c_str(), defaults_[i].c_str()));
            }
        }
        if (type_ == Argument::INFINITE_NUMBER_POSITIONAL_ARGUMENT || type_ == Argument::MULTI_NUMBER_OPTION ||
            type_ == Argument::MULTI_NUMBER_INFINITE_OPTION) {
            if (defaults_.size() % nargs_ != 0) {
                throw ArgumentException(nameOrFlags_.front().c_str(),
                                        "invalid number of argument with number of default argument");
            }
            for (std::size_t i = 0; i < defaults_.size() / nargs_; ++i) {
                if (i > 0) {
                    default_ += ", ";
                }
                default_ += "(";
                ArgumentElement newNumberArgument;
                for (std::size_t j = 0; j < nargs_; ++j) {
                    if (j > 0) {
                        default_ += ", ";
                        newNumberArgument.default_ += ", ";
                    }
                    default_ += defaults_[i * nargs_ + j];
                    newNumberArgument.default_ += defaults_[i * nargs_ + j];
                    newNumberArgument.push_back(
                        ArgumentElement(defaults_[i * nargs_ + j].c_str(), defaults_[i * nargs_ + j].c_str()));
                }
                default_ += ")";
                push_back(newNumberArgument);
            }
        }
    }
}

inline void Argument::clear_() {
    argument_ = default_;
    isNumber_ = false;
    number_ = 0.0;
    count_ = 0;
    isExist_ = false;
    for (std::size_t i = 0; i < size(); ++i) {
        at(i).argument_ = at(i).default_;
        at(i).isNumber_ = false;
        at(i).number_ = 0.0;
        for (std::size_t j = 0; j < at(i).size(); ++j) {
            at(i).at(j).argument_ = at(i).at(j).default_;
            at(i).at(j).isNumber_ = false;
            at(i).at(j).number_ = 0.0;
        }
    }
}

} // namespace args

} // namespace blet

#undef ARGS_PREFIX_SIZEOF_SHORT_OPTION_
#undef ARGS_PREFIX_SIZEOF_LONG_OPTION_

// --------------------
// End src/argument.cpp
// --------------------

// -----------------------
// Start src/exception.cpp
// -----------------------
/**
 * exception.cpp
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2024 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// #include "blet/args/exception.h" (already included)

namespace blet {

namespace args {

inline Exception::Exception(const char* str) :
    std::exception(),
    str_(str) {}

inline Exception::~Exception() throw() {}

inline const char* Exception::what() const throw() {
    return str_.c_str();
}

inline HelpException::HelpException(const char* message) :
    Exception(message) {}

inline HelpException::~HelpException() throw() {}

inline VersionException::VersionException(const char* message) :
    Exception(message) {}

inline VersionException::~VersionException() throw() {}

inline ArgumentException::ArgumentException(const char* message) :
    Exception(message),
    argument_() {}

inline ArgumentException::ArgumentException(const char* argument, const char* message) :
    Exception(message),
    argument_(argument) {}

inline ArgumentException::~ArgumentException() throw() {}

inline const char* ArgumentException::argument() const throw() {
    return argument_.c_str();
}

inline AccessDeniedException::AccessDeniedException(const char* argument, const char* message) :
    ArgumentException(argument, message) {}

inline AccessDeniedException::~AccessDeniedException() throw() {}

inline ParseArgumentException::ParseArgumentException(const char* message) :
    ArgumentException(message) {}

inline ParseArgumentException::ParseArgumentException(const char* argument, const char* message) :
    ArgumentException(argument, message) {}

inline ParseArgumentException::~ParseArgumentException() throw() {}

inline ParseArgumentRequiredException::ParseArgumentRequiredException(const char* argument, const char* message) :
    ParseArgumentException(argument, message) {}

inline ParseArgumentRequiredException::~ParseArgumentRequiredException() throw() {}

inline ParseArgumentValidException::ParseArgumentValidException(const char* message) :
    ParseArgumentException(message) {}

inline ParseArgumentValidException::ParseArgumentValidException(const char* argument, const char* message) :
    ParseArgumentException(argument, message) {}

inline ParseArgumentValidException::~ParseArgumentValidException() throw() {}

} // namespace args

} // namespace blet

// ---------------------
// End src/exception.cpp
// ---------------------

// -------------------
// Start src/usage.cpp
// -------------------
/**
 * usage.cpp
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2024 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// #include "blet/args/usage.h" (already included)

#include <sstream>

// #include "blet/args/args.h" (already included)
// #include "blet/args/argument.h" (already included)

#if defined _WIN32 || defined _WIN64 || defined __CYGWIN__
#define ARGS_SEPARATOR_PATH_ '\\'
#else
#define ARGS_SEPARATOR_PATH_ '/'
#endif

namespace blet {

namespace args {

inline Usage::Usage(Args& args) :
    args_(args),
    description_(std::string()),
    epilog_(std::string()),
    usage_(std::string()),
    usagePadWidth_(2),
    usageArgsWidth_(20),
    usageSepWidth_(2),
    usageHelpWidth_(56) {}

inline Usage::~Usage() {}

static inline std::list<std::string> s_multilineWrap(const std::string& str, std::size_t widthMax) {
    std::list<std::string> lines;
    std::string line;
    std::istringstream iss(str);
    while (std::getline(iss, line)) {
        while (line.size() >= widthMax) {
            std::size_t spacePos = line.rfind(' ', widthMax);
            if (spacePos != std::string::npos) {
                lines.push_back(line.substr(0, spacePos));
                while (spacePos < line.size() && line.at(spacePos) == ' ') {
                    ++spacePos;
                }
                line = line.substr(spacePos);
            }
            else {
                break;
            }
        }
        lines.push_back(line);
    }
    return lines;
}

inline std::string Usage::getUsage() const {
    if (!usage_.empty()) {
        return usage_;
    }
    std::ostringstream oss("");
    bool hasOption = false;
    bool hasPositionnal = false;
    bool hasMultiLine = false;
    // get basename of binaryName
    std::string binaryName;
    std::size_t lastDirCharacterPos = args_.binaryName_.rfind(ARGS_SEPARATOR_PATH_);
    if (lastDirCharacterPos != std::string::npos) {
        binaryName = args_.binaryName_.substr(lastDirCharacterPos + 1);
    }
    else {
        binaryName = args_.binaryName_;
    }
    // usage line
    std::string usageLine = std::string("usage: ") + binaryName;
    oss << usageLine;
    std::size_t binaryPad = usageLine.size();
    std::size_t index = binaryPad;
    std::size_t indexMax = usagePadWidth_ + usageArgsWidth_ + usageSepWidth_ + usageHelpWidth_;
    std::list<Argument*>::const_iterator it;
    for (it = args_.arguments_.begin(); it != args_.arguments_.end(); ++it) {
        if ((*it)->isPositionnalArgument_()) {
            hasPositionnal = true;
            continue;
        }
        hasOption = true;
        std::ostringstream ossArgument("");
        if (!(*it)->isRequired_) {
            ossArgument << '[';
        }
        ossArgument << (*it)->nameOrFlags_.front();
        switch ((*it)->type_) {
            case Argument::SIMPLE_OPTION:
            case Argument::NUMBER_OPTION:
            case Argument::INFINITE_OPTION:
            case Argument::MULTI_OPTION:
            case Argument::MULTI_INFINITE_OPTION:
            case Argument::MULTI_NUMBER_OPTION:
            case Argument::MULTI_NUMBER_INFINITE_OPTION:
                if ((*it)->metavar_.empty()) {
                    ossArgument << ' ' << (*it)->metavarDefault_();
                }
                else {
                    ossArgument << ' ' << (*it)->metavar_;
                }
                break;
            default:
                break;
        }
        if (!(*it)->isRequired_) {
            ossArgument << ']';
        }
        std::string argument = ossArgument.str();
        if (index + argument.size() >= indexMax) {
            hasMultiLine = true;
            oss << '\n' << std::string(binaryPad + 1, ' ') << argument;
            index = binaryPad + argument.size() + 1;
        }
        else {
            oss << ' ' << argument;
            index += argument.size() + 1;
        }
    }
    if (hasOption && hasPositionnal) {
        if (hasMultiLine || index + 3 >= indexMax) {
            oss << '\n' << std::string(binaryPad + 1, ' ') << "--\n" << std::string(binaryPad, ' ');
            index = binaryPad;
        }
        else {
            oss << " --";
            index += 3;
        }
    }
    for (it = args_.arguments_.begin(); it != args_.arguments_.end(); ++it) {
        if (!(*it)->isPositionnalArgument_()) {
            continue;
        }
        std::ostringstream ossArgument("");
        if (!(*it)->isRequired_) {
            ossArgument << '[';
        }
        if ((*it)->type_ == Argument::POSITIONAL_ARGUMENT) {
            ossArgument << (*it)->nameOrFlags_.front();
        }
        else if ((*it)->type_ == Argument::NUMBER_POSITIONAL_ARGUMENT) {
            for (std::size_t i = 0; i < (*it)->nargs_; ++i) {
                if (i != 0) {
                    ossArgument << ' ';
                }
                ossArgument << (*it)->nameOrFlags_.front();
            }
        }
        else if ((*it)->type_ == Argument::INFINITE_POSITIONAL_ARGUMENT) {
            ossArgument << (*it)->nameOrFlags_.front() << " {" << (*it)->nameOrFlags_.front() << "}...";
        }
        else if ((*it)->type_ == Argument::INFINITE_NUMBER_POSITIONAL_ARGUMENT) {
            ossArgument << "{";
            for (std::size_t i = 0; i < (*it)->nargs_; ++i) {
                if (i != 0) {
                    ossArgument << ' ';
                }
                ossArgument << (*it)->nameOrFlags_.front();
            }
            ossArgument << "}...";
        }
        if (!(*it)->isRequired_) {
            ossArgument << ']';
        }
        std::string argument = ossArgument.str();
        if (index + argument.size() >= indexMax) {
            hasMultiLine = true;
            oss << '\n' << std::string(binaryPad + 1, ' ') << argument;
            index = binaryPad + argument.size() + 1;
        }
        else {
            oss << ' ' << argument;
            index += argument.size() + 1;
        }
    }
    // description
    if (!description_.empty()) {
        oss << '\n';
        std::list<std::string> lines = s_multilineWrap(description_, indexMax);
        for (std::list<std::string>::const_iterator cit = lines.begin(); cit != lines.end(); ++cit) {
            oss << '\n';
            oss << *cit;
        }
    }
    // optionnal
    if (!args_.arguments_.empty()) {
        if (hasPositionnal) {
            index = 0;
            oss << "\n\npositional arguments:\n";
            for (it = args_.arguments_.begin(); it != args_.arguments_.end(); ++it) {
                if (!(*it)->isPositionnalArgument_()) {
                    continue;
                }
                if (index != 0) {
                    oss << '\n';
                }
                ++index;
                oss << std::string(usagePadWidth_, ' ');
                if ((*it)->nameOrFlags_.front().size() + usageSepWidth_ <= usageArgsWidth_ + usageSepWidth_) {
                    oss.width(usageArgsWidth_ + usageSepWidth_);
                    oss.flags(std::ios::left);
                    oss << (*it)->nameOrFlags_.front();
                    oss.width(0);
                }
                else {
                    oss << (*it)->nameOrFlags_.front();
                    oss << '\n';
                    oss << std::string(usagePadWidth_ + usageArgsWidth_ + usageSepWidth_, ' ');
                }
                std::ostringstream ossHelp("");
                ossHelp << (*it)->help_;
                if ((*it)->isRequired_) {
                    ossHelp << " (required)";
                }
                else {
                    if (!(*it)->default_.empty()) {
                        ossHelp << " (default: " + (*it)->default_ + ")";
                    }
                }
                std::list<std::string> lines = s_multilineWrap(ossHelp.str(), usageHelpWidth_);
                for (std::list<std::string>::const_iterator cit = lines.begin(); cit != lines.end(); ++cit) {
                    if (cit != lines.begin()) {
                        oss << '\n';
                        oss << std::string(usagePadWidth_ + usageArgsWidth_ + usageSepWidth_, ' ');
                    }
                    oss << *cit;
                }
            }
        }
        if (hasOption) {
            index = 0;
            oss << "\n\noptional arguments:\n";
            for (it = args_.arguments_.begin(); it != args_.arguments_.end(); ++it) {
                if ((*it)->isPositionnalArgument_()) {
                    continue;
                }
                if (index != 0) {
                    oss << '\n';
                }
                ++index;
                std::ostringstream ossArgument("");
                for (std::size_t i = 0; i < (*it)->nameOrFlags_.size(); ++i) {
                    if (i != 0) {
                        ossArgument << ", ";
                    }
                    ossArgument << (*it)->nameOrFlags_[i];
                }
                switch ((*it)->type_) {
                    case Argument::SIMPLE_OPTION:
                    case Argument::NUMBER_OPTION:
                    case Argument::INFINITE_OPTION:
                    case Argument::MULTI_OPTION:
                    case Argument::MULTI_INFINITE_OPTION:
                    case Argument::MULTI_NUMBER_OPTION:
                    case Argument::MULTI_NUMBER_INFINITE_OPTION:
                        if ((*it)->metavar_.empty()) {
                            ossArgument << ' ';
                            ossArgument << (*it)->metavarDefault_();
                        }
                        else {
                            ossArgument << ' ';
                            ossArgument << (*it)->metavar_;
                        }
                        break;
                    default:
                        break;
                }
                const std::string option = ossArgument.str();
                oss << std::string(usagePadWidth_, ' ');
                if (option.size() + usageSepWidth_ <= usageArgsWidth_ + usageSepWidth_) {
                    oss.width(usageArgsWidth_ + usageSepWidth_);
                    oss.flags(std::ios::left);
                    oss << option;
                    oss.width(0);
                }
                else {
                    oss << option;
                    oss << '\n';
                    oss << std::string(usagePadWidth_ + usageArgsWidth_ + usageSepWidth_, ' ');
                }
                std::ostringstream ossHelp("");
                ossHelp << (*it)->help_;
                if ((*it)->isRequired_) {
                    ossHelp << " (required)";
                }
                else {
                    if (!(*it)->default_.empty()) {
                        ossHelp << " (default: " + (*it)->default_ + ")";
                    }
                }
                std::list<std::string> lines = s_multilineWrap(ossHelp.str(), usageHelpWidth_);
                for (std::list<std::string>::const_iterator cit = lines.begin(); cit != lines.end(); ++cit) {
                    if (cit != lines.begin()) {
                        oss << '\n';
                        oss << std::string(usagePadWidth_ + usageArgsWidth_ + usageSepWidth_, ' ');
                    }
                    oss << *cit;
                }
            }
        }
    }
    // epilog
    if (!epilog_.empty()) {
        oss << '\n';
        std::list<std::string> lines = s_multilineWrap(epilog_, indexMax);
        for (std::list<std::string>::const_iterator cit = lines.begin(); cit != lines.end(); ++cit) {
            oss << '\n';
            oss << *cit;
        }
    }
    return oss.str();
}

} // namespace args

} // namespace blet

#undef ARGS_SEPARATOR_PATH_

// -----------------
// End src/usage.cpp
// -----------------

// -------------------
// Start src/valid.cpp
// -------------------
/**
 * valid.cpp
 *
 * Licensed under the MIT License <http://opensource.org/licenses/MIT>.
 * Copyright (c) 2022-2024 BLET Mickael.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

// #include "blet/args/valid.h" (already included)

#include <sys/stat.h>

#include <cstdlib>
#include <sstream>

// #include "blet/args/exception.h" (already included)

namespace blet {

namespace args {

/*
################################################################################
 ValidNumber
################################################################################
*/

inline ValidNumber::ValidNumber() {}
inline ValidNumber::~ValidNumber() {}

inline bool ValidNumber::isValid(std::vector<std::string>& args) {
    for (std::size_t i = 0; i < args.size(); ++i) {
        char* endPtr = NULL;
        ::strtod(args[i].c_str(), &endPtr);
        if (endPtr != NULL && endPtr[0] != '\0') {
            std::ostringstream oss("");
            oss << "\"" << args[i] << "\" is not a number";
            throw ParseArgumentValidException(oss.str().c_str());
        }
    }
    return true;
}

/*
################################################################################
 ValidMinMax
################################################################################
*/

inline ValidMinMax::ValidMinMax(double min, double max) :
    min_(min),
    max_(max) {
    // bad initialized reverse value
    if (min > max) {
        min_ = max;
        max_ = min;
    }
}

inline ValidMinMax::~ValidMinMax() {}

inline bool ValidMinMax::isValid(std::vector<std::string>& args) {
    for (std::size_t i = 0; i < args.size(); ++i) {
        std::stringstream ssArg("");
        ssArg << args[i];
        double number;
        if (!(ssArg >> number)) {
            std::ostringstream oss("");
            oss << "\"" << args[i] << "\" is not a number";
            throw ParseArgumentValidException(oss.str().c_str());
        }
        if (number < min_ || number > max_) {
            std::ostringstream oss("");
            oss << args[i] << " is not between " << min_ << " and " << max_;
            throw ParseArgumentValidException(oss.str().c_str());
        }
    }
    return true;
}

/*
################################################################################
 ValidChoise
################################################################################
*/

inline ValidChoise::ValidChoise(const std::vector<std::string>& choises) :
    choises_(choises) {}

inline ValidChoise::~ValidChoise() {}

inline bool ValidChoise::isValid(std::vector<std::string>& args) {
    std::ostringstream ossChoise("");
    for (std::size_t i = 0; i < choises_.size(); ++i) {
        if (i > 0) {
            ossChoise << ", ";
        }
        ossChoise << '\"' << choises_[i] << '\"';
    }
    for (std::size_t i = 0; i < args.size(); ++i) {
        std::size_t j;
        for (j = 0; j < choises_.size(); ++j) {
            if (args[i] == choises_[j]) {
                break;
            }
        }
        if (j == choises_.size()) {
            std::ostringstream oss("");
            oss << '\"' << args[i] << "\" is not a valid choise (" << ossChoise.str() << ')';
            throw ParseArgumentValidException(oss.str().c_str());
        }
    }
    return true;
}

/*
################################################################################
 ValidPath
################################################################################
*/

inline ValidPath::ValidPath(enum eMode mode) :
    mode_(mode) {}

inline ValidPath::~ValidPath() {}

inline bool ValidPath::isValid(std::vector<std::string>& args) {
    struct stat statBuff;
    for (std::size_t i = 0; i < args.size(); ++i) {
        if (::stat(args[i].c_str(), &statBuff) == -1) {
            std::ostringstream oss("");
            oss << '\"' << args[i] << "\" is not a valid path";
            throw ParseArgumentValidException(oss.str().c_str());
        }
        if (mode_ == ValidPath::IS_DIR && !S_ISDIR(statBuff.st_mode)) {
            std::ostringstream oss("");
            oss << '\"' << args[i] << "\" is not a valid directory";
            throw ParseArgumentValidException(oss.str().c_str());
        }
        else if (mode_ == ValidPath::IS_FILE && !S_ISREG(statBuff.st_mode)) {
            std::ostringstream oss("");
            oss << '\"' << args[i] << "\" is not a valid file";
            throw ParseArgumentValidException(oss.str().c_str());
        }
    }
    return true;
}

} // namespace args

} // namespace blet

// -----------------
// End src/valid.cpp
// -----------------

#endif // #ifndef AMALGAMATE_GUARD__SINGLE_INCLUDE_BLET_ARGS_H_
